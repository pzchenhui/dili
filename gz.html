<!DOCTYPE html>
<html>
<head>
    <title>Earth Revolution and Rotation</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }
        .control-btn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .control-btn:hover {
            background: #45a049;
        }
        .control-btn.active {
            background: #2196F3;
        }
        .season-marker {
            position: absolute;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            padding: 5px;
            background: rgba(0,0,0,0.7);
            border-radius: 3px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">地球公转示意图<br>使用鼠标拖动改变视角<br>使用滚轮缩放</div>
    <div id="controls">
        <button id="start" class="control-btn">开始</button>
        <button id="pause" class="control-btn">暂停</button>
        <button id="speedDown" class="control-btn">减速</button>
        <button id="speedUp" class="control-btn">加速</button>
        <button id="toggleEcliptic" class="control-btn">显示黄道面</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let sun, earth, earthOrbit, earthGroup, eclipticPlane;
        let autoRotate = true;
        let speedMultiplier = 1;
        let isEclipticVisible = false;
        const EARTH_RADIUS = 3;
        const ORBIT_RADIUS_X = 25;
        const ORBIT_RADIUS_Z = 20;
        const SUN_RADIUS = 1.5;
        const ECLIPTIC_ANGLE = 23.5 * Math.PI / 180; // 黄道倾角（23.5度）

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 20, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 创建太阳
            const sunGeometry = new THREE.SphereGeometry(SUN_RADIUS, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00
            });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // 添加太阳光源
            const sunLight = new THREE.PointLight(0xffffff, 2);
            sun.add(sunLight);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // 创建黄道面但初始设为不可见
            createEclipticPlane();

            // 创建椭圆轨道（在黄道面上）
            createEllipticalOrbit();

            // 创建地球组（用于公转）
            earthGroup = new THREE.Group();
            scene.add(earthGroup);

            // 创建地球
            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 32, 32);
            const earthTexture = new THREE.TextureLoader().load(
                'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
                function(texture) {
                    renderer.render(scene, camera);
                }
            );
            const earthMaterial = new THREE.MeshPhongMaterial({ 
                map: earthTexture,
                specular: new THREE.Color(0x333333),
                shininess: 5
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            
            // 修改这里：将地轴倾角改为正值
            earth.rotation.x = ECLIPTIC_ANGLE; // 从负值改为正值，原来是 -ECLIPTIC_ANGLE
            earthGroup.add(earth);

            // 添加地轴
            const axisLength = EARTH_RADIUS * 2.5;
            const axisGeometry = new THREE.CylinderGeometry(0.05, 0.05, axisLength, 32);
            const axisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const axis = new THREE.Mesh(axisGeometry, axisMaterial);
            earth.add(axis);

            // 添加纬线
            addLatitudeLines(earth);

            // 添加四季标记点
            addSeasonMarkers();

            createStars();
            initControls();

            window.addEventListener('resize', onWindowResize, false);
        }

        function createEclipticPlane() {
            const planeGeometry = new THREE.PlaneGeometry(ORBIT_RADIUS_X * 2.2, ORBIT_RADIUS_Z * 2.2);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            eclipticPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            eclipticPlane.rotation.x = Math.PI / 2;
            eclipticPlane.visible = false; // 初始设置为不可见
            scene.add(eclipticPlane);
        }

        function createEllipticalOrbit() {
            const curve = new THREE.EllipseCurve(
                0, 0,
                ORBIT_RADIUS_X, ORBIT_RADIUS_Z,
                0, 2 * Math.PI,
                false,
                0
            );

            const points = curve.getPoints(100);
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const orbitMaterial = new THREE.LineBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.5
            });
            
            earthOrbit = new THREE.Line(orbitGeometry, orbitMaterial);
            earthOrbit.rotation.x = Math.PI / 2;
            scene.add(earthOrbit);
        }

        function addLatitudeLines(earth) {
            const latitudes = [
                { angle: 0, color: 0xffff00, name: "赤道" },
                { angle: 23.5, color: 0xff0000, name: "北回归线" },
                { angle: -23.5, color: 0xff0000, name: "南回归线" },
                { angle: 66.5, color: 0x0000ff, name: "北极圈" },
                { angle: -66.5, color: 0x0000ff, name: "南极圈" }
            ];

            latitudes.forEach(lat => {
                const radius = EARTH_RADIUS * Math.cos(lat.angle * Math.PI / 180);
                const height = EARTH_RADIUS * Math.sin(lat.angle * Math.PI / 180);
                
                const latitudeGeometry = new THREE.TorusGeometry(radius, 0.04, 16, 100);
                const latitudeMaterial = new THREE.MeshBasicMaterial({ 
                    color: lat.color,
                    transparent: true,
                    opacity: 0.8
                });
                const latitudeLine = new THREE.Mesh(latitudeGeometry, latitudeMaterial);
                
                latitudeLine.rotation.x = Math.PI / 2;
                latitudeLine.position.y = height;
                
                earth.add(latitudeLine);
            });
        }

        function addSeasonMarkers() {
            const seasons = [
                { angle: Math.PI / 2, name: "冬至" },     // 右侧 - 夏至
                { angle: Math.PI, name: "春分" },         // 上方 - 秋分
                { angle: -Math.PI / 2, name: "夏至" },    // 左侧 - 冬至
                { angle: 0, name: "秋分" }                // 下方 - 春分
            ];

            seasons.forEach(season => {
                const x = Math.cos(season.angle) * ORBIT_RADIUS_X;
                const z = Math.sin(season.angle) * ORBIT_RADIUS_Z;

                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                marker.position.set(x, 0, z);
                scene.add(marker);

                const div = document.createElement('div');
                div.className = 'season-marker';
                div.textContent = season.name;
                document.body.appendChild(div);

                marker.userData = {
                    label: div,
                    angle: season.angle
                };
            });
        }

        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.1,
                sizeAttenuation: true
            });

            const starsVertices = [];
            for(let i = 0; i < 5000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000);
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', 
                new THREE.Float32BufferAttribute(starsVertices, 3));
            
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function initControls() {
            document.getElementById('start').addEventListener('click', () => {
                autoRotate = true;
                updateButtonStates();
            });

            document.getElementById('pause').addEventListener('click', () => {
                autoRotate = false;
                updateButtonStates();
            });

            document.getElementById('speedUp').addEventListener('click', () => {
                speedMultiplier = Math.min(speedMultiplier * 1.5, 5);
            });

            document.getElementById('speedDown').addEventListener('click', () => {
                speedMultiplier = Math.max(speedMultiplier * 0.75, 0.1);
            });

            // 添加黄道面显示控制
            const toggleEclipticBtn = document.getElementById('toggleEcliptic');
            toggleEclipticBtn.addEventListener('click', () => {
                isEclipticVisible = !isEclipticVisible;
                eclipticPlane.visible = isEclipticVisible;
                toggleEclipticBtn.classList.toggle('active');
                toggleEclipticBtn.textContent = isEclipticVisible ? '隐藏黄道面' : '显示黄道面';
            });
        }

        function updateButtonStates() {
            document.getElementById('start').classList.toggle('active', autoRotate);
            document.getElementById('pause').classList.toggle('active', !autoRotate);
        }

        function updateSeasonMarkers() {
            scene.children.forEach(child => {
                if (child.userData && child.userData.label) {
                    const vector = new THREE.Vector3();
                    vector.setFromMatrixPosition(child.matrixWorld);
                    vector.project(camera);

                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                    child.userData.label.style.transform = `translate(-50%, -50%)`;
                    child.userData.label.style.left = `${x}px`;
                    child.userData.label.style.top = `${y}px`;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                const time = Date.now() * 0.001 * speedMultiplier;
                const angle = time * 0.5;
                
                // 更新地球位置
                earth.position.x = Math.cos(angle) * ORBIT_RADIUS_X;
                earth.position.z = Math.sin(angle) * ORBIT_RADIUS_Z;

                // 保持地轴指向固定
                earth.rotation.y = -angle;
                earth.rotation.x = ECLIPTIC_ANGLE; // 这里也改为正值
            }

            updateSeasonMarkers();
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
